// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: user_question.sql

package repositories

import (
	"context"
)

const getUserQuestion = `-- name: GetUserQuestion :one
SELECT question_id, slide_id, username, content, votes, answered, created_at
FROM "user_question"
WHERE question_id = $1
`

func (q *Queries) GetUserQuestion(ctx context.Context, questionID string) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, getUserQuestion, questionID)
	var i UserQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.SlideID,
		&i.Username,
		&i.Content,
		&i.Votes,
		&i.Answered,
		&i.CreatedAt,
	)
	return i, err
}

const listUserQuestion = `-- name: ListUserQuestion :many
SELECT question_id, slide_id, username, content, votes, answered, created_at
FROM "user_question"
WHERE slide_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserQuestion(ctx context.Context, slideID string) ([]UserQuestion, error) {
	rows, err := q.db.QueryContext(ctx, listUserQuestion, slideID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserQuestion{}
	for rows.Next() {
		var i UserQuestion
		if err := rows.Scan(
			&i.QuestionID,
			&i.SlideID,
			&i.Username,
			&i.Content,
			&i.Votes,
			&i.Answered,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleUserQuestionAnswered = `-- name: ToggleUserQuestionAnswered :one
UPDATE "user_question"
SET answered = NOT answered
WHERE question_id = $1
RETURNING question_id, slide_id, username, content, votes, answered, created_at
`

func (q *Queries) ToggleUserQuestionAnswered(ctx context.Context, questionID string) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, toggleUserQuestionAnswered, questionID)
	var i UserQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.SlideID,
		&i.Username,
		&i.Content,
		&i.Votes,
		&i.Answered,
		&i.CreatedAt,
	)
	return i, err
}

const upsertUserQuestion = `-- name: UpsertUserQuestion :one
INSERT INTO "user_question" (
  "question_id",
  "slide_id",
  "username",
  "content",
  "created_at"
) VALUES (
    $1, $2, $3, $4, now()
) ON CONFLICT (question_id) DO UPDATE SET
    "slide_id" = $2,
    "username" = $3,
    "content" = $4
RETURNING question_id, slide_id, username, content, votes, answered, created_at
`

type UpsertUserQuestionParams struct {
	QuestionID string `json:"question_id"`
	SlideID    string `json:"slide_id"`
	Username   string `json:"username"`
	Content    string `json:"content"`
}

func (q *Queries) UpsertUserQuestion(ctx context.Context, arg UpsertUserQuestionParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, upsertUserQuestion,
		arg.QuestionID,
		arg.SlideID,
		arg.Username,
		arg.Content,
	)
	var i UserQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.SlideID,
		&i.Username,
		&i.Content,
		&i.Votes,
		&i.Answered,
		&i.CreatedAt,
	)
	return i, err
}

const upvoteUserQuestion = `-- name: UpvoteUserQuestion :one
UPDATE "user_question"
SET votes = votes + 1
WHERE question_id = $1
RETURNING question_id, slide_id, username, content, votes, answered, created_at
`

func (q *Queries) UpvoteUserQuestion(ctx context.Context, questionID string) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, upvoteUserQuestion, questionID)
	var i UserQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.SlideID,
		&i.Username,
		&i.Content,
		&i.Votes,
		&i.Answered,
		&i.CreatedAt,
	)
	return i, err
}
